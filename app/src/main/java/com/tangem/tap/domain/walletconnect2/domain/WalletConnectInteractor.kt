package com.tangem.tap.domain.walletconnect2.domain

import com.tangem.tap.common.extensions.filterNotNull
import com.tangem.tap.domain.walletconnect.WalletConnectSdkHelper
import com.tangem.tap.domain.walletconnect2.data.WalletConnectSessionsRepositoryImpl
import com.tangem.tap.domain.walletconnect2.domain.models.Account
import com.tangem.tap.domain.walletconnect2.domain.models.NetworkNamespace
import com.tangem.tap.domain.walletconnect2.domain.models.Session
import com.tangem.tap.domain.walletconnect2.domain.models.WalletConnectError
import com.tangem.tap.domain.walletconnect2.domain.models.WalletConnectEvents
import com.tangem.tap.domain.walletconnect2.domain.models.WalletConnectSession
import com.tangem.tap.features.details.ui.walletconnect.WcSessionForScreen
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import timber.log.Timber

class WalletConnectInteractor(
    private val handler: WalletConnectEventsHandler,
    private val walletConnectRepository: WalletConnectRepository,
    private val sessionsRepository: WalletConnectSessionsRepositoryImpl,
    private val sdkHelper: WalletConnectSdkHelper,
    val blockchainHelper: WcBlockchainHelper,
) {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    private val events = walletConnectRepository.events
    private val sessions = walletConnectRepository.activeSessions

    private var userWalletId: String = ""
    private var cardId: String? = null

    private var currentRequest: WalletConnectEvents.SessionRequest? = null
    private val sessionRequestConverter = WcSessionRequestConverter(
        blockchainHelper = blockchainHelper,
        sessionsRepository = sessionsRepository,
        sdkHelper = sdkHelper,
    )

    fun startListening(userWalletId: String, cardId: String?) {
        this.userWalletId = userWalletId
        this.cardId = cardId
        events
            .onEach { wcEvent ->
                when (wcEvent) {
                    is WalletConnectEvents.SessionProposal -> {
                        Timber.d("WC session proposal event received")
                        val networksFormatted = wcEvent.chainIds
                            .mapNotNull { blockchainHelper.chainIdToFullNameOrNull(it) }
                            .toString()
                        handler.onProposalReceived(proposal = wcEvent, networksFormatted = networksFormatted)
                    }
                    is WalletConnectEvents.SessionApprovalError -> {
                        val error = when (wcEvent.error) {
                            is WalletConnectError.ApprovalErrorMissingNetworks -> {
                                val missingNetworks = wcEvent.error.missingChains
                                    .map { blockchainHelper.chainIdToNetworkIdOrNull(it) }
                                val containsUnsupportedNetworks = missingNetworks.any { it == null }
                                if (containsUnsupportedNetworks) {
                                    WalletConnectError.ApprovalErrorUnsupportedNetwork
                                } else {
                                    WalletConnectError.ApprovalErrorAddNetwork(missingNetworks.filterNotNull())
                                }
                            }
                            else -> wcEvent.error
                        }
                        handler.onSessionRejected(error)
                    }
                    is WalletConnectEvents.SessionApprovalSuccess -> {
                        sessionsRepository.saveSession(
                            userWallet = userWalletId,
                            session = Session.fromAccounts(
                                accounts = wcEvent.accounts,
                                topic = wcEvent.topic,
                            ),
                        )
                        handler.onSessionEstablished()
                    }
                    is WalletConnectEvents.SessionDeleted -> {
                        sessionsRepository.removeSession(userWalletId, wcEvent.topic)
                    }
                    is WalletConnectEvents.SessionRequest -> {
                        handleRequest(wcEvent)
                    }
                }
            }
            .launchIn(scope)

        sessions
            .onEach { listOfSessions ->
                val relevantTopics = getTopicsForUserWallet(userWalletId, sessionsRepository)
                val filteredSessions = filterSessionsForUserWallet(listOfSessions, relevantTopics)
                handler.onListOfSessionsUpdated(filteredSessions)
            }
            .launchIn(scope)

        walletConnectRepository.updateSessions()
    }

    private fun filterSessionsForUserWallet(
        availableSessions: List<WalletConnectSession>,
        relevantTopics: List<String>,
    ): List<WcSessionForScreen> {
        return availableSessions.filter { relevantTopics.contains(it.topic) }
            .map {
                WcSessionForScreen(
                    description = it.name ?: "",
                    sessionId = it.topic,
                )
            }
    }

    private suspend fun getTopicsForUserWallet(
        userWalletId: String,
        repository: WalletConnectSessionsRepository,
    ): List<String> {
        return repository.loadSessions(userWalletId).map { it.topic }
    }

    fun approveSessionProposal(accounts: List<Account>) {
        val userNamespaces: Map<NetworkNamespace, List<Account>> = accounts
            .groupBy { account ->
                blockchainHelper.getNamespaceFromFullChainId(account.chainId)
                    ?.let { NetworkNamespace(it) }
            }.filterNotNull()
        walletConnectRepository.approve(
            userNamespaces = userNamespaces,
        )
    }

    fun rejectSessionProposal() {
        walletConnectRepository.reject()
    }

    fun disconnectSession(topic: String) {
        walletConnectRepository.disconnect(topic)
    }

    private fun handleRequest(sessionRequest: WalletConnectEvents.SessionRequest) {
        scope.launch {
            if (sessionsRepository.loadSessions(userWalletId).none { it.topic == sessionRequest.topic }) {
                handler.onSessionRequestForWrongUserWallet()
                walletConnectRepository.rejectRequest(sessionRequest.topic, sessionRequest.id)
                return@launch
            }
            when (sessionRequest.request) {
                is WcRequest.BnbCancel -> Unit
                is WcRequest.BnbTxConfirm -> walletConnectRepository.sendRequest(
                    topic = sessionRequest.topic,
                    id = sessionRequest.id,
                    result = "",
                )
                else -> {
                    currentRequest = sessionRequest
                    val data = prepareRequestData(sessionRequest)
                    if (data != null) {
                        handler.onSessionRequest(data)
                    }
                }
            }
        }
    }

    fun continueWithRequest(request: WcPreparedRequest) {
        val currentRequest = this.currentRequest
        if (currentRequest == null || request.topic != currentRequest.topic) return

        scope.launch {
            val signedHash = when (request) {
                is WcPreparedRequest.BnbTransaction -> sdkHelper.signBnbTransaction(
                    data = request.preparedRequestData.data.data,
                    networkId = blockchainHelper.chainIdToNetworkIdOrNull(currentRequest.chainId ?: "")
                        ?: return@launch,
                    derivationPath = request.derivationPath,
                    cardId = cardId,
                )
                is WcPreparedRequest.EthTransaction -> sdkHelper.completeTransaction(
                    data = request.preparedRequestData,
                    cardId = cardId,
                )
                is WcPreparedRequest.EthSign -> sdkHelper.signPersonalMessage(
                    hashToSign = request.preparedRequestData.hash,
                    networkId = blockchainHelper.chainIdToNetworkIdOrNull(currentRequest.chainId ?: "")
                        ?: return@launch,
                    derivationPath = request.derivationPath,
                    cardId = cardId,
                )
            }

            Timber.d("Signed hash: $signedHash")

            if (signedHash == null) {
                walletConnectRepository.rejectRequest(
                    topic = request.topic,
                    id = request.requestId,
                )
            } else {
                walletConnectRepository.sendRequest(
                    topic = request.topic,
                    id = request.requestId,
                    result = signedHash,
                )
            }
        }
    }

    private suspend fun prepareRequestData(sessionRequest: WalletConnectEvents.SessionRequest): WcPreparedRequest? {
        return sessionRequestConverter.prepareRequest(sessionRequest, userWalletId)
    }
}
